# This is SCRIPT 2: The Data Visualizer
#
# It reads the pre-processed data from 'analysis_data.npz'
# and focuses *only* on drawing the visualization.
#
# It also plays the original audio file for perfect sync.
#
# Requires: pip install pygame numpy

import pygame
import numpy as np
import sys

# --- Configuration ---
# The data file generated by pre-analyzer.py
INPUT_DATA_FILE = "analysis_data.npz"

# Graphics settings
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
BG_COLOR = (10, 10, 30)
BAR_COLOR = (50, 200, 255)
BAR_COLOR_HIGH = (255, 200, 50)
PEAK_COLOR = (255, 50, 50)
BEAT_FLASH_COLOR = (200, 200, 200)

# Circle and wave settings
CENTER_X = SCREEN_WIDTH // 2
CENTER_Y = SCREEN_HEIGHT // 2
NUM_CIRCLES = 5  # Number of concentric circles
NUM_WAVE_POINTS = 128  # Points in the circular wave

# --- Main Visualizer ---
def run_visualizer():
    # --- 1. Load Analysis Data ---
    print(f"Loading analysis data from {INPUT_DATA_FILE}...")
    try:
        data = np.load(INPUT_DATA_FILE, allow_pickle=True)
    except FileNotFoundError:
        print(f"Error: File '{INPUT_DATA_FILE}' not found.")
        print("Please run 'pre-analyzer.py' first.")
        sys.exit()

    # Extract our data arrays
    mel_spec = data['mel_spec']     # (N_MELS, T)
    rms = data['rms']               # (1, T)
    beat_frames = data['beat_frames'] # (N_Beats,)
    VIS_FPS = float(data['vis_fps'])
    AUDIO_FILE = str(data['audio_file'])
    
    # Get dimensions
    NUM_BARS = mel_spec.shape[0]  # e.g., 128
    TOTAL_FRAMES = mel_spec.shape[1] # e.g., 15000
    
    # Pre-calculate bar-drawing info
    BAR_WIDTH = SCREEN_WIDTH / NUM_BARS
    
    # Convert beat_frames into a simple lookup for speed
    # A set is much faster for "is_beat = current_frame in beat_set"
    beat_set = set(beat_frames)
    
    print("Data loaded. Starting visualizer...")

    # --- 2. Initialize Pygame and Audio ---
    pygame.init()
    pygame.mixer.init() # Initialize the mixer for audio
    
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    pygame.display.set_caption("Pre-Processed Audio Visualizer")
    clock = pygame.time.Clock()

    # Load and play the *original* audio file
    try:
        pygame.mixer.music.load(AUDIO_FILE)
        pygame.mixer.music.play()
        print(f"Playing audio: {AUDIO_FILE}")
    except Exception as e:
        print(f"Error playing audio file {AUDIO_FILE}: {e}")
        pygame.quit()
        sys.exit()

    # --- 3. Main Visualization Loop ---
    running = True
    current_frame = 0 # This is our "time"
    
    # For smoothing
    current_bar_heights = np.zeros(NUM_BARS)
    SMOOTHING_FACTOR = 0.85
    
    # Background pulse for beat effects
    bg_pulse = 0.0
    
    # Wave rotation for dynamic effect
    wave_rotation = 0.0

    while running and current_frame < TOTAL_FRAMES:
        # --- Event Handling ---
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
        
        # Check if audio is still playing
        if not pygame.mixer.music.get_busy() and current_frame > 100:
            print("Audio finished.")
            running = False # Stop when audio stops

        # --- Get Data for This Frame ---
        # This is super fast, just an array lookup!
        
        # 1. Get frequency data (scaled logarithmically)
        # We scale the spectrogram data (which is in dB) for visual height
        raw_heights = (mel_spec[:, current_frame] + 80) / 80 # Normalize from -80dB
        scaled_heights = np.clip(raw_heights, 0, 1) * (SCREEN_HEIGHT - 50)
        
        # Apply smoothing
        current_bar_heights = np.maximum(scaled_heights, current_bar_heights * SMOOTHING_FACTOR)

        # 2. Get volume data
        # We can use this to make a circle pulse, etc.
        volume = rms[0, current_frame]
        
        # 3. Check for beat
        is_beat = current_frame in beat_set

        # --- Graphics Drawing ---
        # Apply background pulse (brighten on beats)
        pulse_brightness = int(bg_pulse * 80)
        bg_color_pulsed = (
            min(255, BG_COLOR[0] + pulse_brightness),
            min(255, BG_COLOR[1] + pulse_brightness),
            min(255, BG_COLOR[2] + pulse_brightness)
        )
        screen.fill(bg_color_pulsed)
        
        # Flash effect on beat
        if is_beat:
            bg_pulse = 1.0
            
        # --- Draw Concentric Circles (pulsing with volume) ---
        base_radius = 30 + volume * 400
        for i in range(NUM_CIRCLES):
            radius = int(base_radius + i * 40 * (1 + bg_pulse * 0.3))
            alpha = 255 - i * 40
            color_mix = i / NUM_CIRCLES
            color = (
                int((1 - color_mix) * BAR_COLOR[0] + color_mix * BAR_COLOR_HIGH[0]),
                int((1 - color_mix) * BAR_COLOR[1] + color_mix * BAR_COLOR_HIGH[1]),
                int((1 - color_mix) * BAR_COLOR[2] + color_mix * BAR_COLOR_HIGH[2])
            )
            if radius < SCREEN_WIDTH:
                pygame.draw.circle(screen, color, (CENTER_X, CENTER_Y), radius, 2 + int(bg_pulse * 3))
        
        # --- Draw Circular Wave (frequency data as radius modulation) ---
        # Resample frequency data to match wave points
        if NUM_BARS >= NUM_WAVE_POINTS:
            # Downsample
            step = NUM_BARS // NUM_WAVE_POINTS
            wave_data = current_bar_heights[::step][:NUM_WAVE_POINTS]
        else:
            # Upsample with interpolation
            indices = np.linspace(0, NUM_BARS - 1, NUM_WAVE_POINTS)
            wave_data = np.interp(indices, np.arange(NUM_BARS), current_bar_heights)
        
        # Normalize wave data for radius modulation
        wave_normalized = wave_data / (SCREEN_HEIGHT - 50) if np.max(wave_data) > 0 else wave_data
        
        # Create wave points
        wave_points = []
        base_wave_radius = 150 + volume * 200
        for i in range(NUM_WAVE_POINTS):
            angle = (2 * np.pi * i / NUM_WAVE_POINTS) + wave_rotation
            # Modulate radius based on frequency data
            radius_mod = wave_normalized[i] * 100
            radius = base_wave_radius + radius_mod
            x = CENTER_X + int(radius * np.cos(angle))
            y = CENTER_Y + int(radius * np.sin(angle))
            wave_points.append((x, y))
        
        # Draw the wave as a closed polygon
        if len(wave_points) > 2:
            # Draw filled polygon with transparency effect
            pygame.draw.polygon(screen, BAR_COLOR, wave_points, 0)
            # Draw outline
            pygame.draw.polygon(screen, BAR_COLOR_HIGH, wave_points, 3)
        
        # --- Draw Secondary Wave (inverted phase) ---
        wave_points2 = []
        for i in range(NUM_WAVE_POINTS):
            angle = (2 * np.pi * i / NUM_WAVE_POINTS) - wave_rotation
            # Use opposite side of spectrum for variety
            opposite_idx = (i + NUM_WAVE_POINTS // 2) % NUM_WAVE_POINTS
            radius_mod = wave_normalized[opposite_idx] * 60
            radius = base_wave_radius * 0.6 + radius_mod
            x = CENTER_X + int(radius * np.cos(angle))
            y = CENTER_Y + int(radius * np.sin(angle))
            wave_points2.append((x, y))
        
        if len(wave_points2) > 2:
            pygame.draw.polygon(screen, PEAK_COLOR, wave_points2, 2)
        
        # Decay pulse and rotate wave
        bg_pulse *= 0.90
        wave_rotation += 0.02 * (1 + volume * 2)


        # Update the display
        pygame.display.flip()
        
        # --- Sync and Advance Frame ---
        # This is the magic!
        # We tick the clock at the *exact* FPS we calculated from the analysis.
        # This keeps the video (our loop) perfectly in sync with the audio.
        clock.tick(VIS_FPS)
        current_frame += 1

    # --- 4. Cleanup ---
    print("Shutting down...")
    pygame.mixer.music.stop()
    pygame.quit()

if __name__ == "__main__":
    run_visualizer()